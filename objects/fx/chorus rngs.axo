<objdefs appVersion="1.0.10">
   <obj.normal id="chorus rngs" uuid="fefe9ec6-1b22-431f-ad8f-09529a3fb5e6">
      <sDescription>Chorus effect from Mutable Instrumnets Rings</sDescription>
      <license>GPL</license>
      <inlets>
         <frac32buffer name="l"/>
         <frac32buffer name="r"/>
      </inlets>
      <outlets>
         <frac32buffer name="l"/>
         <frac32buffer name="r"/>
      </outlets>
      <displays/>
      <params>
         <frac32.u.map name="amount"/>
         <frac32.u.map name="depth"/>
      </params>
      <attribs/>
      <code.declaration><![CDATA[rings::Chorus chorus;

uint16_t * alloc_buffer(){
	static uint16_t buffer[32768] __attribute__ ((section (".sdram")));
	return buffer;
}]]></code.declaration>
      <code.init><![CDATA[chorus.Init(alloc_buffer());]]></code.init>
      <code.krate><![CDATA[static float left[BUFSIZE];
static float right[BUFSIZE];

int i;

chorus.set_amount(q27_to_float(param_amount));
chorus.set_depth(q27_to_float(param_depth));

for(i=0;i<BUFSIZE;i++){
	left[i] = q27_to_float(inlet_l[i]);
	right[i] = q27_to_float(inlet_r[i]);
}

chorus.Process(left,right,BUFSIZE);

for(i=0;i<BUFSIZE;i++){
	outlet_l[i] = float_to_q27(left[i]);
	outlet_r[i] = float_to_q27(right[i]);
}]]></code.krate>
   </obj.normal>
</objdefs>