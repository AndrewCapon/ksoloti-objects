<objdefs appVersion="1.0.12">
   <obj.normal id="lmnts" uuid="361A8551-0FF8-4559-9D34-6419E86449E7">
      <sDescription>an elements-like effect, based on open source DSP code from mutable instruments.
any bugs/issues you find are our own, report on the axoloti forum.

Thanks to Olivier Gillet from Mutable Instruments for open sourcing their code.
http://mutable-instruments.com</sDescription>
      <author>Mark Harris</author>
      <license>GPL</license>
      <helpPatch>lmnts.axh</helpPatch>
      <inlets>
         <frac32buffer name="blow"/>
         <frac32buffer name="strike"/>
         <bool32 name="gate"/>
         <frac32.bipolar name="pitch"/>
         <frac32.bipolar name="modulation"/>
         <frac32.positive name="strength"/>
      </inlets>
      <outlets>
         <frac32buffer name="l"/>
         <frac32buffer name="r"/>
      </outlets>
      <displays/>
      <params>
         <frac32.u.map name="contour"/>
         <frac32.u.map name="bow level"/>
         <frac32.u.map name="bow timbre"/>
         <frac32.u.map name="blow level"/>
         <frac32.u.map name="blow flow"/>
         <frac32.u.map name="blow timbre"/>
         <frac32.u.map name="strike level"/>
         <frac32.u.map name="strike mallet"/>
         <frac32.u.map name="strike timbre"/>
         <frac32.u.map name="geometry"/>
         <frac32.u.map name="brightness"/>
         <frac32.u.map name="damping"/>
         <frac32.u.map name="position"/>
         <frac32.u.map name="space"/>
         <frac32.s.map name="pitch"/>
         <frac32.u.map name="seed"/>
      </params>
      <attribs>
         <combo name="resonator">
            <MenuEntries>
               <string>modal</string>
               <string>string</string>
               <string>strings</string>
            </MenuEntries>
            <CEntries>
               <string>1</string>
               <string>2</string>
               <string>3</string>
            </CEntries>
         </combo>
      </attribs>
      <file-depends>
         <file-depend localFilename="smp_noise_sample.raw" targetPath="/shared/elements/smp_noise_data.raw"/>
         <file-depend localFilename="smp_sample_data.raw" targetPath="/shared/elements/smp_sample_data.raw"/>
      </file-depends>
      <includes>
         <include>axoloti_mi.h</include>
      </includes>
      <code.declaration><![CDATA[elements::Part part;
uint32_t seed=0;


inline float constrainQ27(int32_t v, float vMin, float vMax) {
	return std::max<float>(vMin,std::min<float>(vMax, q27_to_float(v)));
}

inline float constrain(float v, float vMin, float vMax) {
	return std::max<float>(vMin,std::min<float>(vMax, v));
}]]></code.declaration>
      <code.init><![CDATA[const int SAMPLE_SZ = 256026;
const int NOISE_SZ = 81926;

bool r = false;
LogTextMessage("sdram_get_free %d",sdram_get_free());

int16_t* smp_sample_data = (int16_t*) sdram_malloc(SAMPLE_SZ);
if(!smp_sample_data) return;
 
r = loadElementsData(0,"/shared/elements/smp_sample_data.raw",smp_sample_data,SAMPLE_SZ/2);

int16_t* smp_noise_data= (int16_t*) sdram_malloc(NOISE_SZ);
if(!smp_noise_data) return;

if(r) r = loadElementsData(1,"/shared/elements/smp_noise_data.raw",smp_noise_data,NOISE_SZ/2);

if(r) {
   LogTextMessage("Elements loading sample complete, SDRAM free %d", sdram_get_free() );
}

const int ELEMENTS_SZ= 32768;
part.Init( (uint16_t *) sdram_malloc(ELEMENTS_SZ) );

LogTextMessage("Elements initialised, SDRAM free %d", sdram_get_free() );

part.set_resonator_model(elements::ResonatorModel(attr_resonator));]]></code.init>
      <code.krate><![CDATA[static float blow_in[BUFSIZE];
static float strike_in[BUFSIZE];
static float left[BUFSIZE];
static float right[BUFSIZE];

int i;

part.mutable_patch()->exciter_envelope_shape	= constrainQ27(param_contour			,0.0f, 1.0f);
part.mutable_patch()->exciter_bow_level		= constrainQ27(param_bow_space_level	,0.0f, 1.0f);
part.mutable_patch()->exciter_bow_timbre	= constrainQ27(param_bow_space_timbre	,0.0f, 1.0f);
part.mutable_patch()->exciter_blow_level	= constrainQ27(param_blow_space_level	,0.0f, 1.0f);
part.mutable_patch()->exciter_blow_meta		= constrainQ27(param_blow_space_flow	,0.0f, 1.0f);
part.mutable_patch()->exciter_blow_timbre	= constrainQ27(param_blow_space_timbre	,0.0f, 1.0f);
part.mutable_patch()->exciter_strike_level	= constrainQ27(param_strike_space_level	,0.0f, 1.0f);
part.mutable_patch()->exciter_strike_meta	= constrainQ27(param_strike_space_mallet	,0.0f, 1.0f);
part.mutable_patch()->exciter_strike_timbre	= constrainQ27(param_strike_space_timbre	,0.0f, 1.0f);
part.mutable_patch()->resonator_geometry	= constrainQ27(param_geometry			,0.0f, 1.0f);
part.mutable_patch()->resonator_brightness	= constrainQ27(param_brightness		,0.0f, 1.0f);
part.mutable_patch()->resonator_damping		= constrainQ27(param_damping			,0.0f, 1.0f);
part.mutable_patch()->resonator_position	= constrainQ27(param_position			,0.0f, 1.0f);
part.mutable_patch()->space				= constrain(q27_to_float(param_space) * 2.0, 0.0f, 2.0f);

if(seed!=param_seed) {
	seed = param_seed;
	part.Seed(&seed, 1);
}
 
for(i=0;i<BUFSIZE;i++){
   blow_in[i] 	 = q27_to_float(inlet_blow[i]);
   strike_in[i] = q27_to_float(inlet_strike[i]);
}

elements::PerformanceState state;
state.gate = inlet_gate > 0;
state.note 		= constrain(q27_to_float(param_pitch + inlet_pitch) * 60.0f,-60.0f, 60.0f);
state.modulation 	= constrainQ27(inlet_modulation, 0.0f,1.0f) * 60.0f;
state.strength 	= constrainQ27(inlet_strength, 0.0f,1.0f);

part.Process(state, blow_in, strike_in, left, right, BUFSIZE);

for(i=0;i<BUFSIZE;i++){
   outlet_l[i] = float_to_q27(left[i]);
   outlet_r[i] = float_to_q27(right[i]);
}]]></code.krate>
   </obj.normal>
</objdefs>